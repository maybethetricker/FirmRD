from use_define.utils import SINKS
from use_define.use_def_checker import Use_Def_Checker

import string
import angr
import os
DEBUG=False

#this class store global informations for library function summary, such as the current function sammaries that are already generated,
# and the safe_functions in a library which are functions that surely won't reach sink function( save it in order to do pruch and save analysing time)
# and the project and cfg info to safe the loading time of angr
#this class is a unique class generated by using singleton
class Lib_global_info():
    lib_function_summaries={}
    # if a function's all sub-functions can't reach any sink or can reach sink but the sink's parameter can't reach the function's input parameters, regard it as a safe function
    lib_globalSafeFuncs={}
    # store the project and cfg pointers since analysing cfg usually cost too much time
    lib_project_info={}
    #a globally saved dict for each library for all use-def analysed result done yet, save in order to avoid repeat analysing use-def 
    lib_usedef_analysed_calls={}
    #the root directory of the file system to be analysed, used for finding the path of the libraries
    fs_path=None

    #this class is a unique class, and the instance variable always point at itself
    _instance = None

    #a use of singleton, in order to make the class unique
    def __new__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = object.__new__(cls, *args, **kw)
        return cls._instance

    def __init__(self):
        pass

    #since this class is a singleton, we need to clear its information for each file system(to-be-analysed device) to avoid loading the result of the former device
    def clear_singleton_info(self,fs_path):
        self.fs_path=fs_path
        self.lib_function_summaries={}
        self.lib_globalSafeFuncs={}
        self.lib_project_info={}
        self.lib_usedef_analysed_calls={}

    #get function summary info, if the function summary is not yet generated, return None
    def get_function_summary(self,function_name):
        if function_name not in self.lib_function_summaries.keys():
            return None
        else:
            return self.lib_function_summaries[function_name]

    def output_all_function_summaries(self,output_dir):
        for key in self.lib_function_summaries.keys():
            value=self.lib_function_summaries[key]
            for (sinkable_arg_set,partial_path_info) in value:
                for sink_name,sink_path in partial_path_info:
                    path=[]
                    i=len(sink_path)-1
                    addr, callee = sink_path[i][:2]
                    path.append(addr)
                    while(i>0):
                        i-=1
                        addr, callee = sink_path[i][:2]
                        path.append(callee)
                        path.append(addr)
                    path.append(0)#top function
                    if DEBUG:
                        print(path)
                    f=open(output_dir,'a')
                    f.write("library function "+key+" reached sink "+sink_name+",sink path:")
                    depth=int((len(path)-1)/2)
                    while depth>=0:
                        call_addr, function = path[2*depth],path[2*depth+1]
                        f.write('Func %s -> %s >>' % (str(hex(function)),str(hex(call_addr))))
                        depth-=1
                    f.write('>>sink\n')

    #given the function name, generate function summary for a lib import function
    #if the function surely won't reach any sink, it's a safe function, the function summary is an empty list
    #else, the function may reach a sink, store the argument of the function that may reach sink and the sink it may reach and the path from the function to sink
    def generate_function_summary(self,function_name,function_summary_info):
        self.lib_function_summaries[function_name]=function_summary_info

    #generate the project and cfg for a to be analysed library and save it globally
    def store_project_info(self,lib_name):
        lib_path=self.find_lib_path(lib_name)
        if lib_path is None:#can't find the library under the fs path
            self.lib_project_info[lib_name]=(None,None)
            return
        project=angr.Project(lib_path,auto_load_libs=False)
        cfg=project.analyses.CFG(resolve_indirect_jumps=True, cross_references=True, 
                                force_complete_scan=False, normalize=True, symbols=True)
        self.lib_project_info[lib_name]=(project,cfg)
    
    #load the project and cfg info of a library
    def load_project_info(self,lib_name):
        if lib_name not in self.lib_project_info.keys():#project is not stored yet, store it
            self.store_project_info(lib_name)
        return self.lib_project_info[lib_name]

    #if we found a global safe function in a library with lib_name, store its addr in global information
    def save_globalSafeFunc(self,lib_name,safe_func_addr):
        if lib_name not in self.lib_globalSafeFuncs.keys():
            self.lib_globalSafeFuncs[lib_name]=set()
        self.lib_globalSafeFuncs[lib_name].add(safe_func_addr)

    #return the current globalSafeFunctions of a library
    def load_globalSafeFunc(self,lib_name):
        if lib_name not in self.lib_globalSafeFuncs.keys():
            self.lib_globalSafeFuncs[lib_name]=set()
        return self.lib_globalSafeFuncs[lib_name]

    # get prune info "analysed_calls" and "length_limit_result" and save it as a global variable
    def get_lib_usedef_analysed_result(self,lib_name):
        if lib_name not in self.lib_usedef_analysed_calls.keys():
            self.lib_usedef_analysed_calls[lib_name]=({},{})
        return self.lib_usedef_analysed_calls[lib_name]

    # SAVE prune info "analysed_calls" and "length_limit_result" as global variables
    def set_lib_usedef_analysed_result(self,lib_name,analysed_call,length_limit_result):
        self.lib_usedef_analysed_calls[lib_name]=(analysed_call,length_limit_result)

    #find the path of a library
    def find_lib_path(self,lib_name):
        for root,dirs,files in os.walk(self.fs_path):
            for file in files:
                if file.endswith(lib_name):
                    return os.path.join(root,file)
        return None

#generate function summary for an import function that may be referenced in border binaries EXCEPT the functions in commonly-used libraries(eg:libc,libgcc)
#since there might be vulnerables in these import functions, these function summaries can ensure that the taint-analyse can reach vulnerabilities in libraries,
#but usually, functions in commonly-used libraries aren't vulnerable(regardless of supply-chain vulnerables),so we simply skipped them
#use the term of lazy-binding, if an import function is referenced in the dfs path and it's function summary is not yet generated, then generate it
class Lib_Function_Summarizer():
    common_libs=["ld","gcc","pthread","libcrypto","ssl","libc.so","libdl.so"]#some commonly_referenced libraries

    def __init__(self, target_binary_refed_libs, import_function_name,debug=False):
        self.target_bin_refed_lib=target_binary_refed_libs# the libraries that is linked with a binary, given by project.loader.requested_names
        self.target_func_name=import_function_name#the import function that is called by the border binary(which trigger lazy-binding)

        global DEBUG
        DEBUG = debug

    #generate function summary for the target function
    def generate_func_summary(self):
        #find which library that the target function is in
        for lib in self.target_bin_refed_lib:
            for common_lib in self.common_libs:
                if common_lib in lib:
                    continue
            #find whether the import function is in a library(and return true or false), if true, analyse it at the same time
            if self.find_import_func_in_lib(lib,self.target_func_name):
                break
        lib_info_instance=Lib_global_info()
        func_summary=lib_info_instance.get_function_summary(self.target_func_name)
        if func_summary is None:#if the target function is not found, the function summary is still None, which will trigger infinite recurse, therefore, set the function summary to be empty list
            func_summary=[]
            lib_info_instance.generate_function_summary(self.target_func_name,func_summary)
        if DEBUG:
            print("generate function summary for ",self.target_func_name," in ",self.target_bin_refed_lib)
            print("the function summary is:",func_summary)

    #find whether the import function is in a library(and return true or false), if true, analyse it at the same time
    def find_import_func_in_lib(self,lib_name,target_func_name):
        #get the project and cfg global info
        lib_info_instance=Lib_global_info()
        #check whether the target function is in this library
        target_func_addr=None
        project,cfg=lib_info_instance.load_project_info(lib_name)
        if project is None or cfg is None:# when the path can't be found, which means we can't find the library under the fs path, skip the analyse of the library
            return False
        symbols=project.loader.main_object.symbols
        for symbol in symbols:
            if symbol.is_export:#it's an export function
                if symbol.name == target_func_name:
                    target_func_addr=symbol.relative_addr+project.loader.main_object.min_addr
        if target_func_addr is not None:#the target function is the export function of this library, analyse it
            #find the function by its name
            start_func=cfg.kb.functions.get_by_addr(target_func_addr)
            if start_func is not None:
                #dfs through the function to check sink, the prune and analysing args here is different from the dfs in use-def main function
                function_summary=self.lib_find_sink_path(lib_name,start_func)
                lib_info_instance.generate_function_summary(target_func_name,function_summary)
            else:
                print("error:can't find the export function",lib_name,target_func_name)
            return True
        else:#the import function is not in this library, check other library
            return False

    #dfs through the function to check sink, the prune and analysing args here is different from the dfs in use-def main function
    def lib_find_sink_path(self,lib_name,start_func):
        currentSinkReachableFuncs=[]#while in one dfs,check all paths to confirm the final global_safe_func, if a function can reach a sink, it is not global_safe
        function_summary=[]

        # path: a argument that stores the list of the path from source to sink, format:[(addr of call, callee), (addr of call, callee), ...]
        def lib_dfs(func,call_sites,path):
            lib_info_instance=Lib_global_info()
            project,cfg=lib_info_instance.load_project_info(lib_name)
            if func.name in SINKS and len(path):
                #return True#test the speed of dfs
                # parsed the path into the format that use_define analyse can accept(since we need to analyse from sink to source, but orig path is from source to sink)
                check_path=[]
                i=len(path)-1
                addr, callee = path[i][:2]
                check_path.append(addr)
                while(i>0):
                    i-=1
                    addr, callee = path[i][:2]
                    check_path.append(callee)
                    check_path.append(addr)
                check_path.append(start_func.addr)
                #when analysing lib functions, we do not need a import param as a source, we just check whether the sink can reach the arguments of this import function, if true, it may influence the user-input parsed into the import function
                #therefore, by adding one depth(regardless of its content) and set yield_analyse=false, the analyse will only stops when depth==max_depth,which is the time that it has checked whether the sink can reach the arguments of the import function
                check_path.append(start_func.addr)#addr of the useless depth
                check_path.append(start_func.addr)#callee of the useless depth
                check_path.append([0x1])#useless input parameter, ensure that it won't be reached
                tmp_key=[func.name,check_path]
                #check use_define, after adding yield analyse, analyse will stop after reaching the top of the import function
                #if sinked, then the arguments of the import function may be influenced by sink, else, it is not influenced
                #depth:if sink can't reached source, in which depth it failed to reach upper function(a information used to Prune)
                #eg: funcA->funB->funC->sink,sink can reach arguments of funC, but can't reach arguments of funcB, so depth is 0
                analysed_call,length_limit_result=lib_info_instance.get_lib_usedef_analysed_result(lib_name)
                use_def_checker=Use_Def_Checker(analysed_call,length_limit_result,DEBUG)
                lib_info_instance.set_lib_usedef_analysed_result(lib_name,analysed_call,length_limit_result)
                sinked,depth=use_def_checker.check_use_define(project,cfg,tmp_key,"")#since yield analyse=false,the output directory is actually not used
                key_path=tmp_key[1]
                if sinked:#the argument of the function can reach the sink
                    #now it returns [ref_addr, current_call_addr, function_containning_calladdr, args, sinkname] as depth
                    #store the current sinkable function summary(as the dfs is not yet finished, we will update the function summary at last)
                    argset_refered=False
                    for (sinkable_args_set,sink_path_info) in function_summary:
                        if sinkable_args_set==depth[3]:
                            argset_refered=True
                            sink_path_info.append((depth[4],path))#add the sink name and sink path to the corresponding arg set
                            break
                    if not argset_refered:
                        function_summary.append((depth[3],[(depth[4],path)]))#add the sink name and sink path to the corresponding arg set
                    depth=int((len(key_path)-1)/2)#for all function including the top function, they are all sink_reachable and not global safe
                #for all functions that sink can reach it, store it as it is not global_safe
                depth-=1        
                while depth>=0:
                    if key_path[2*depth+1] not in currentSinkReachableFuncs:
                        currentSinkReachableFuncs.append(key_path[2*depth+1])
                    depth-=1
                return True
            if func.is_plt and len(path):#in very few situations, the export func is in plt, and the plt item points at the export function itself, therefore, when len(path)==0, simply regard it as a jmp inside the binary
                #it's a library import function
                recurse_func_summary=lib_info_instance.get_function_summary(func.name)
                if recurse_func_summary is None:#lazy binding: generate function summary for the function
                    func_summarizer=Lib_Function_Summarizer(project.loader.requested_names,func.name)#if the import function called another import function, analyse the function summary recursely
                    func_summarizer.generate_func_summary()
                    recurse_func_summary=lib_info_instance.get_function_summary(func.name)
                if recurse_func_summary is not None:#after lazy binding, we still cannot generate the function summary, most likely, the function is in a library that can't be found under the fs path
                    for (sinkable_arg_set,partial_path_info) in recurse_func_summary:#each item means a sink path from the target funtion to a sink function, if the import function is safe, then the function summary is an empty list
                        #consider the sinkable import function as a sink function, analyse the use define from the function to the top of the target import function
                        # parsed the path into the format that use_define analyse can accept(since we need to analyse from sink to source, but orig path is from source to sink)
                        check_path=[]
                        i=len(path)-1
                        addr, callee = path[i][:2]
                        check_path.append(addr)
                        while(i>0):
                            i-=1
                            addr, callee = path[i][:2]
                            check_path.append(callee)
                            check_path.append(addr)
                        check_path.append(start_func.addr)
                        #when analysing lib functions, we do not need a import param as a source, we just check whether the sink can reach the arguments of this import function, if true, it may influence the user-input parsed into the import function
                        #as we need to reuse yield_analyse=True to set the need_check_arguments of the interested library function, by setting the input parameter into an useless address, the analyse will just stop until it reached the max depth
                        #therefore, if the sink did not reach the arguments of the import function, the returned depth should be maxdepth, if it reached the arguments, then it's depth should be maxdepth+1 and it will reach the last "return" of use_def_checker.check_use_define
                        check_path.append([0x1])#useless input parameter, ensure that it won't be reached
                        #reuse the processing method of yield analyse since we need to continue an analyse with the given call address and arg set
                        tmp_sink_name,tmp_partial_path=partial_path_info[0]#the name of the sink function and the path from summarised func to sink which is required for the output of yield-analyse, actually unused here because the source here will never be reached
                        argset=sinkable_arg_set#which argument of current call_addr can reach a sink
                        check_path.append(argset)
                        check_path.append(tmp_partial_path)
                        tmp_key=[tmp_sink_name,check_path]
                        #check use def, similiar with the condition when func.name in sink
                        analysed_call,length_limit_result=lib_info_instance.get_lib_usedef_analysed_result(lib_name)
                        use_def_checker=Use_Def_Checker(analysed_call,length_limit_result,DEBUG)
                        lib_info_instance.set_lib_usedef_analysed_result(lib_name,analysed_call,length_limit_result)
                        sinked,depth=use_def_checker.check_use_define(project,cfg,tmp_key,"",yield_analyse=True)#since the refaddr is unreachable,the output directory is actually not used
                        key_path=tmp_key[1]
                        if type(depth)==list:#the argument of the function can reach sink
                            #I changed the format of the return value corresponding to this condition in the last line of use_def_checker.py in order to return the argset information
                            depth,argset=depth
                            #store the current sinkable function summary(as the dfs is not yet finished, we will update the function summary at last)
                            argset_refered=False
                            for (orig_args_set,orig_path_info) in function_summary:
                                if orig_args_set==argset:
                                    argset_refered=True
                                    #combine the path from sink to the sinkable import function and the path from the sinkable import function to the top of the target function
                                    for sink_name,partial_path in partial_path_info:
                                        combined_path=path+partial_path#after combining, the path is [...(call_to_sinkable_imp_func,sinkable_imp_func),HERE IS THE COMBINE POINT (call_in_the_sinkable_imp_func,callee_func)...(call_to_sinkfunc,sinkfunc)]
                                        orig_path_info.append((sink_name,combined_path))#add the sink name and sink path to the corresponding arg set
                                    break
                            if not argset_refered:
                                path_info_list=[]
                                #combine the path from sink to the sinkable import function and the path from the sinkable import function to the top of the target function
                                for sink_name,partial_path in partial_path_info:
                                    combined_path=path+partial_path#after combining, the path is [...(call_to_sinkable_imp_func,sinkable_imp_func),HERE IS THE COMBINE POINT (call_in_the_sinkable_imp_func,callee_func)...(call_to_sinkfunc,sinkfunc)]
                                    path_info_list.append((sink_name,combined_path))#add the sink name and sink path to the corresponding arg set
                                function_summary.append((argset,path_info_list))#add the sink name and sink path to the corresponding arg set
                        #for all functions that sink can reach it, store it as it is not global_safe
                        depth-=1        
                        while depth>=0:
                            if key_path[2*depth+1] not in currentSinkReachableFuncs:
                                currentSinkReachableFuncs.append(key_path[2*depth+1])
                            depth-=1
                    return True
                return False#the function summary is None, we can't find any sink under this import function, therefore regard this function as an unsinkable function
            #if a function is global_safe, we don't need to analyse again
            if func.addr in lib_info_instance.load_globalSafeFunc(lib_name) and func.addr != start_func.addr:#ensure it is not start_func(as sink in startfunc may can reach source as they are in the same function)
                return False
            sinkReached = False
            # dfs search all calls in a function recursely, until we find a sink
            for call_site in call_sites:
                basic_block = project.factory.block(call_site)
                if basic_block:
                    callee=cfg.model.get_any_node(basic_block.addr).successors[0].addr#the seccessor is the callee function
                    if DEBUG:
                        print(callee)
                    if callee in [x[1] for x in path] + [func.addr]:#prevent dead loop
                        continue
                    callee_func=None
                    for tmp_func_addr, tmp_func in cfg.kb.functions.items():
                        if callee==tmp_func_addr:
                            callee_func=tmp_func
                            break
                    if DEBUG:
                        print("callee_func",callee_func)
                    if callee_func == None:
                        continue
                    call_addr=basic_block.instruction_addrs[-1]
                    #a node of path is in the form of (call_addr,callee,sinked)
                    #dfs, jump into the callee_function to continue analyse
                    sinkReached = lib_dfs(callee_func, callee_func.get_call_sites(), path + [(call_addr, callee, False)]) or sinkReached
            #prune
            if not sinkReached:#all callsites of this function cannot reach sinks
                #case1:source can't reach any sinks
                lib_info_instance.save_globalSafeFunc(lib_name,func.addr)
            if func.addr not in currentSinkReachableFuncs:
                #case2:all sinks in the sub_funcs all cannot reach current func
                #didn't add func.addr != startFunc.addr, because when analysing library, we always analyse the use-def until we reached the arguments of the start function
                lib_info_instance.save_globalSafeFunc(lib_name,func.addr)
            return sinkReached

        lib_dfs(start_func,start_func.get_call_sites(),[])
        return function_summary
